== Implementation Guide

This document provides the guidelines for the correct implementation of the SCM API.

=== Introduction

The SCM API consists of a number of extension points:

* The original `hudson.scm.SCM` extension point is responsible for:

** performing checkouts from source control into a `FilePath`

** calculating the changelogs between revisions

** constructing the changelog parser

* The `jenkins.scm.SCMSource` extension point is responsible for:

** identifying heads / branches that are available

** tracking the current revisions of heads

** constructing `hudson.scm.SCM` instances for a given head and revision pair

* The `jenkins.scm.SCMNavigator` extension point is responsible for:

** enumerating potential `jenkins.scm.SCMSource` instances

Some examples of how these concepts may be mapped into well known source control systems:

* Git has a fairly direct mapping of concepts

** `jenkins.scm.SCMHead` would represent the branches and tags in an individual Git repository

** `jenkins.scm.SCMRevision` would represent the Git commit hash of each individual commit. Because Git commits are immutable, each `SCMRevision` is deterministic as if you ask to check out the same hash you will always get the same contents.

** `jenkins.scm.SCMSource` would represent a single Git repository.

** `jenkins.scm.SCMNavigator` would represent a collection of Git repositories - most likely all on the same server

* Subversion can have a fairly direct mapping of concepts analogous to the Git mapping above.
Alternatively some oganizations will use a single Subversion repository to hold multiple projects under which each project would have the familiar `trunk/branches/tags` structure. If we consider this style of Subversion use then:

** `jenkins.scm.SCMHead` would be mapped against a specific project and be one of: `trunk`, `branches/_name_` or `tags/_name_`.

** `jenkins.scm.SCMRevision` would be mapped to the global Subversion revision number against which the specific `SCMHead` was last modified. Each `SCMRevision` is deterministic as if you ask to check out the trunk/branch.tag at the same revision you will always get the same contents.

** `jenkins.scm.SCMSource` would represent a single project withi the Subversion repository.

** `jenkins.scm.SCMNavigator` would represent the collection of projects in the root of the Subversion repository.

* CVS, one mapping of the CVS concepts would be:

** `jenkins.scm.SCMHead` would represent a branch in a module.

** `jenkins.scm.SCMRevision` would represent a timestamp. Sadly the timestamp is not deterministic as an immediate checkout may miss some files that are still being committed to the repository.
+
NOTE: An alternative deterministic `jenkins.scm.SCMRevision` would be a list of all the files and their individual revisions, but this would be prohibitive in terms of storage cost and is non-trivial for a user to replicate from their own workspace and consequently the timestamp would be preferred.
Ignoring the problems of time sychronization in a distributed system, we could assume that any timestamp more than _X_ minutes in the past should be deterministic in order to allow the consuming plugins to make optimizations that are only possible with deterministic revisions.

** `jenkins.scm.SCMSource` would represent an individual module on the CVS server.

** `jenkins.scm.SCMNavigator` would represent the collection of modules available from a single CVS server.

Implementers are free to map the concepts to their own SCM system as they see fit, but the recommendation is to try to keep close to the principles of mapping outlined in the above examples.

The concepts we have covered so far determine how Jenkins plugins can drive interactions with the SCM system.
While a Jenkins driven interaction with an SCM is sufficient for enabling advanced SCM functionality such as that provided in the https://wiki.jenkins-ci.org/display/JENKINS/Branch+API+Plugin[Branch API plugin], it does not lend to a good user experience as Jenkins would be required to continually poll the backing SCM to establish if there are any changes.
In order to minimize the load on Jenkins and the SCM system as well as minimize the amount of time between a change being committed to the SCM system and Jenkins responding to the change, it is necessary to implement the eventing portions of the SCM API.

There are currently three classes of events:

* `jenkins.scm.SCMHeadEvent` represents an event concerning a `jenkins.scm.SCMHead` such as:
** the creation of a new `jenkins.scm.SCMHead` within a specific `jenkins.scm.SCMSource`,
** a change in revision of a `jenkins.scm.SCMHead`,
** a change in metadata about a specific `jenkins.scm.SCMHead` and
** the removal of an existing `jenkins.scm.SCMHead` from a `jenkins.scm.SCMSource`
* `jenkins.scm.SCMSourceEvent` represents an event concerning a `jenkins.scm.SCMSource` such as:
** the creation of a new `jenkins.scm.SCMSource` within a specific `jenkins.scm.SCMNavigator`,
** a change in metadata about a specific `jenkins.scm.SCMSource`
** the removal of an existing `jenkins.scm.SCMSource` from a `jenkins.scm.SCMNavigator`
* `jenkins.scm.SCMNavigatorEvent` represents an event concerning a `jenkins.scm.SCMNavigator` such as:
** the creation of a new `jenkins.scm.SCMNavigator`
+
NOTE: there is no use case for this event currently envisioned as it would likely require a containing context for the `jenkins.scm.SCMNavigator` instances.
** a change in metadata about a specific `jenkins.scm.SCMNavigator`
** the removal of an existing `jenkins.scm.SCMNavigator`.

Not every event is required to be provided by the backing SCM system.
The primary events ensure that Jenkins responds promptly to activity in the backing source control system. They are, in order of priority:

1. `jenkins.scm.SCMHeadEvent` of type `UPDATED` representing the change of a revision in a specific head.
When this event is implemented, it removes the need to continually poll for revision changes and builds can be triggered as soon as the event is received which benefits user responsiveness.
2. `jenkins.scm.SCMHeadEvent` of type `CREATED` representing the creation of a new head.
When this event is implemented, it removes the need to continually poll the `jenkins.scm.SCMSource` to identify untracked `jenkins.scm.SCMHead` instances.
3. `jenkins.scm.SCMSourceEvent` of type `CREATED` representing the creation of a new source.
When this event is implemented, it removes the need to continually poll the `jenkins.scm.SCMNavigator` to identify untracked `jenkins.scm.SCMSource` instances.

The secondary events ensure that state changes in the source control system are reflected promptly within Jenkins. These secondary events will not trigger builds. They are, in ordre of priority:

1. `jenkins.scm.SCMHeadEvent` of type `REMOVED` representing the removal a specific head.
When this event is implemented, it means that Jenkins can "deactivate" any resources (i.e. jobs) that are dedicated to tracking that head.
+
NOTE: It is likely that the resources (i.e. jobs) cannot be removed until Jenkins performs a full scan as the SCM API is designed for the use case where you have multiple sources attached to the same owner and the reason for removal from one source may be a move to another source.
Without a full scan of all sources the priority claims of multiple sources cannot be determined
2. `jenkins.scm.SCMSourceEvent` of type `REMOVED` representing the removal of a specific source.
When this event is implemented, it means that Jenkins can "deactivate" any resources (i.e. jobs) that are dedicated to tracking that source.

The tertiary events relate to metadata updates, such as URLs, display names or descriptions about the various resources being tracked.
The kind of tertiary information that these events represent may not be available for all source control systems.
In cases where the source control system provides an API to store such metadata, it may be the case that there are no events generated when the metadata is modified. The tertiary events are, in order of priority:

1. `jenkins.scm.SCMHeadEvent` of type `UPDATED` representing the change of metadata for a specific head, such as the description of a branch / change request
2. `jenkins.scm.SCMSourceEvent` of type `UPDATED` representing the change of metadata for a specific source, such as:
** the description of the source
** the display name of the source
** the information URL of the source
** the avatar of the source
3. `jenkins.scm.SCMNavigatorEvent` of type `UPDATED` representing the change of metadata for a collection of sources as an aggregate, such as:
** the description of the collection
** the display name of the collection
** the information URL of the collection
** the avatar of the collection

Implementations are free to use the event system to publish other events as appropriate providing the type of event is logically mapped.

The next step in implementing the SCM API is to allow for consuming plugins to perform deeper identification of interesting `jenkins.scm.SCMHead` instances.
Consuming plugins may not be interested in every single `jenkins.scm.SCMHead`.
For example:

* the https://wiki.jenkins-ci.org/display/JENKINS/Pipeline+Multibranch+Plugin[Pipeline Multibranch Plugin] is only interested in `jenkins.scm.SCMHead` instances that have a `Jenkinsfile` in the root of the checkout.

* the https://wiki.jenkins-ci.org/display/JENKINS/Literate+Plugin[Literate Plugin] is only interested in `jenkins.scm.SCMHead` instances that have a marker file (configurable with the default being `.cloudbees.md`) in the root of the checkout.

Each SCM API consuming plugin defines the criteria by implementing `jenkins.scm.SCMSourceCriteria`.
Each `jenkins.scm.SCMSourceOwner` can specify the criteria for the `jenkins.scm.SCMSource` instances that it owns.

When a `jenkins.scm.SCMSource` has been supplied with a `jenkins.scm.SCMSourceCriteria` it will need to provide a `jenkins.scm.SCMProbe` when identifying potential `jenkins.scm.SCMHead` instances.

[NOTE]
====
Implementations of `jenkins.scm.SCMProbe` should put primary focus on the `stat(_path_)` method that checks for existence and filetype.
This method is expected to be a hot code path

When a consuming plugin is processing a `jenkins.scm.SCMHeadEvent`, it will be necessary for the consuming plugin to revalidate the head instance against the `jenkins.scm.SCMSourceCriteria`.
Even if we could trust the content of the `jenkins.scm.SCMHeadEvent`, the revalidation would be a necessary step as we have no way of determining from a `jenkins.scm.SCMHeadEvent` whether the change has:

* Transitioned the criteria matching from `false` to `true`;
* Maintained the criteria matching in its current state; or
* Transitioned the criteria matching from `true` to `false.

Thus *every* SCM API consuming plugin that listens for a `jenkins.scm.SCMEvent` will need to validate that event *against the criteria*.
This revalidation would be necessary even if we received a signed trusted event from the backing source control system.
This is why:

* The `jenkins.scm.SCMEvent` is always considered `Untrusted` - consuming plugins will be doing revalidation anyway, so it is simpler for consuming plugins to treat everything from an event as untrusted.
For example, if we receive a `jenkins.scm.SCMHeadEvent` saying that there is a new head with a specific revision.
The revalidation will involve checking if that revision contains the required marker content by calling `jenkins.scm.SCMSource.fetch()` with an observer that is only interested in the head mentioned in the event.
If a malicious event has provided a head that does not exist, then the observer will never be called.
The event provided a revision does not really matter as, the observer will be provided with the actual revision of the named head (though if the event provided revision matches the known revision of the head the consumer can even avoid the call to `jenkins.scm.SCMSource.fetch()` in the first place.

* The `jenkins.scm.SCMEvent` dispatch methods always push events to a background thread - *every* consuming plugin will need to perform revalidation of any claim made from an event.
The revalidation should not block the handling of the webhook that delivered the event, hence the SCM API provides a simpler contract for all consumers by ensuring that the events are always on a separate thread from the webhook processing thread.
====

