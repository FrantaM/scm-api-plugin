== Implementation Guide

This document provides the guidelines for a correct optimal implementation of the SCM API.

=== Introduction

The SCM API consists of a number of extension points:

* The original `hudson.scm.SCM` extension point is responsible for:

** performing checkouts from source control into a `FilePath`

** calculating the changelogs between revisions

** constructing the changelog parser

* The `jenkins.scm.api.SCMSource` extension point is responsible for:

** identifying heads / branches that are available

** tracking the current revisions of heads

** constructing `hudson.scm.SCM` instances for a given head and revision pair

* The `jenkins.scm.api.SCMNavigator` extension point is responsible for:

** enumerating potential `jenkins.scm.api.SCMSource` instances

Some examples of how these concepts may be mapped into well known source control systems:

* Git has a fairly direct mapping of concepts

** `jenkins.scm.api.SCMHead` would represent the branches and tags in an individual Git repository

** `jenkins.scm.api.SCMRevision` would represent the Git commit hash of each individual commit. Because Git commits are immutable, each `SCMRevision` is deterministic as if you ask to check out the same hash you will always get the same contents.

** `jenkins.scm.api.SCMSource` would represent a single Git repository.

** `jenkins.scm.api.SCMNavigator` would represent a collection of Git repositories - most likely all on the same server

* Subversion can have a fairly direct mapping of concepts analogous to the Git mapping above.
Alternatively some oganizations will use a single Subversion repository to hold multiple projects under which each project would have the familiar `trunk/branches/tags` structure. If we consider this style of Subversion use then:

** `jenkins.scm.api.SCMHead` would be mapped against a specific project and be one of: `trunk`, `branches/_name_` or `tags/_name_`.

** `jenkins.scm.api.SCMRevision` would be mapped to the global Subversion revision number against which the specific `SCMHead` was last modified. Each `SCMRevision` is deterministic as if you ask to check out the trunk/branch.tag at the same revision you will always get the same contents.

** `jenkins.scm.api.SCMSource` would represent a single project withi the Subversion repository.

** `jenkins.scm.api.SCMNavigator` would represent the collection of projects in the root of the Subversion repository.

* CVS, one mapping of the CVS concepts would be:

** `jenkins.scm.api.SCMHead` would represent a branch in a module.

** `jenkins.scm.api.SCMRevision` would represent a timestamp. Sadly the timestamp is not deterministic as an immediate checkout may miss some files that are still being committed to the repository.
+
NOTE: An alternative deterministic `jenkins.scm.api.SCMRevision` would be a list of all the files and their individual revisions, but this would be prohibitive in terms of storage cost and is non-trivial for a user to replicate from their own workspace and consequently the timestamp would be preferred.
Ignoring the problems of time sychronization in a distributed system, we could assume that any timestamp more than _X_ minutes in the past should be deterministic in order to allow the consuming plugins to make optimizations that are only possible with deterministic revisions.

** `jenkins.scm.api.SCMSource` would represent an individual module on the CVS server.

** `jenkins.scm.api.SCMNavigator` would represent the collection of modules available from a single CVS server.

Implementers are free to map the concepts to their own SCM system as they see fit, but the recommendation is to try to keep close to the principles of mapping outlined in the above examples.

The concepts we have covered so far determine how Jenkins plugins can drive interactions with the SCM system.
While a Jenkins driven interaction with an SCM is sufficient for enabling advanced SCM functionality such as that provided in the https://wiki.jenkins-ci.org/display/JENKINS/Branch+API+Plugin[Branch API plugin], it does not lend to a good user experience as Jenkins would be required to continually poll the backing SCM to establish if there are any changes.
In order to minimize the load on Jenkins and the SCM system as well as minimize the amount of time between a change being committed to the SCM system and Jenkins responding to the change, it is necessary to implement the eventing portions of the SCM API.

There are currently three classes of events:

* `jenkins.scm.api.SCMHeadEvent` represents an event concerning a `jenkins.scm.api.SCMHead` such as:
** the creation of a new `jenkins.scm.api.SCMHead` within a specific `jenkins.scm.api.SCMSource`,
** a change in revision of a `jenkins.scm.api.SCMHead`,
** a change in metadata about a specific `jenkins.scm.api.SCMHead` and
** the removal of an existing `jenkins.scm.api.SCMHead` from a `jenkins.scm.api.SCMSource`
* `jenkins.scm.api.SCMSourceEvent` represents an event concerning a `jenkins.scm.api.SCMSource` such as:
** the creation of a new `jenkins.scm.api.SCMSource` within a specific `jenkins.scm.api.SCMNavigator`,
** a change in metadata about a specific `jenkins.scm.api.SCMSource`
** the removal of an existing `jenkins.scm.api.SCMSource` from a `jenkins.scm.api.SCMNavigator`
* `jenkins.scm.api.SCMNavigatorEvent` represents an event concerning a `jenkins.scm.api.SCMNavigator` such as:
** the creation of a new `jenkins.scm.api.SCMNavigator`
+
NOTE: there is no use case for this event currently envisioned as it would likely require a containing context for the `jenkins.scm.api.SCMNavigator` instances.
** a change in metadata about a specific `jenkins.scm.api.SCMNavigator`
** the removal of an existing `jenkins.scm.api.SCMNavigator`.

Not every event is required to be provided by the backing SCM system.
The primary events ensure that Jenkins responds promptly to activity in the backing source control system. They are, in order of priority:

1. `jenkins.scm.api.SCMHeadEvent` of type `UPDATED` representing the change of a revision in a specific head.
When this event is implemented, it removes the need to continually poll for revision changes and builds can be triggered as soon as the event is received which benefits user responsiveness.
2. `jenkins.scm.api.SCMHeadEvent` of type `CREATED` representing the creation of a new head.
When this event is implemented, it removes the need to continually poll the `jenkins.scm.api.SCMSource` to identify untracked `jenkins.scm.api.SCMHead` instances.
3. `jenkins.scm.api.SCMSourceEvent` of type `CREATED` representing the creation of a new source.
When this event is implemented, it removes the need to continually poll the `jenkins.scm.api.SCMNavigator` to identify untracked `jenkins.scm.api.SCMSource` instances.

The secondary events ensure that state changes in the source control system are reflected promptly within Jenkins. These secondary events will not trigger builds. They are, in order of priority:

1. `jenkins.scm.api.SCMHeadEvent` of type `REMOVED` representing the removal a specific head.
When this event is implemented, it means that Jenkins can "deactivate" any resources (i.e. jobs) that are dedicated to tracking that head.
+
NOTE: It is likely that the resources (i.e. jobs) cannot be removed until Jenkins performs a full scan as the SCM API is designed for the use case where you have multiple sources attached to the same owner and the reason for removal from one source may be a move to another source.
Without a full scan of all sources the priority claims of multiple sources cannot be determined
2. `jenkins.scm.api.SCMSourceEvent` of type `REMOVED` representing the removal of a specific source.
When this event is implemented, it means that Jenkins can "deactivate" any resources (i.e. jobs) that are dedicated to tracking that source.

The tertiary events relate to metadata updates, such as URLs, display names or descriptions about the various resources being tracked.
The kind of tertiary information that these events represent may not be available for all source control systems.
In cases where the source control system provides an API to store such metadata, it may be the case that there are no events generated when the metadata is modified. The tertiary events are, in order of priority:

1. `jenkins.scm.api.SCMHeadEvent` of type `UPDATED` representing the change of metadata for a specific head, such as the description of a branch / change request
2. `jenkins.scm.api.SCMSourceEvent` of type `UPDATED` representing the change of metadata for a specific source, such as:
** the description of the source
** the display name of the source
** the information URL of the source
** the avatar of the source
3. `jenkins.scm.api.SCMNavigatorEvent` of type `UPDATED` representing the change of metadata for a collection of sources as an aggregate, such as:
** the description of the collection
** the display name of the collection
** the information URL of the collection
** the avatar of the collection

Implementations are free to use the event system to publish other events as appropriate providing the type of event is logically mapped.

The next step in implementing the SCM API is to allow for consuming plugins to perform deeper identification of interesting `jenkins.scm.api.SCMHead` instances.
Consuming plugins may not be interested in every single `jenkins.scm.api.SCMHead`.
For example:

* the https://wiki.jenkins-ci.org/display/JENKINS/Pipeline+Multibranch+Plugin[Pipeline Multibranch Plugin] is only interested in `jenkins.scm.api.SCMHead` instances that have a `Jenkinsfile` in the root of the checkout.

* the https://wiki.jenkins-ci.org/display/JENKINS/Literate+Plugin[Literate Plugin] is only interested in `jenkins.scm.api.SCMHead` instances that have a marker file (configurable with the default being `.cloudbees.md`) in the root of the checkout.

Each SCM API consuming plugin defines the criteria by implementing `jenkins.scm.api.SCMSourceCriteria`.
Each `jenkins.scm.api.SCMSourceOwner` can specify the criteria for the `jenkins.scm.api.SCMSource` instances that it owns.

When a `jenkins.scm.api.SCMSource` has been supplied with a `jenkins.scm.api.SCMSourceCriteria` it will need to provide a `jenkins.scm.api.SCMProbe` when identifying potential `jenkins.scm.api.SCMHead` instances.

[NOTE]
====
Implementations of `jenkins.scm.api.SCMProbe` should put primary focus on the `stat(_path_)` method that checks for existence and filetype.
This method is expected to be a hot code path

When a consuming plugin is processing a `jenkins.scm.api.SCMHeadEvent`, it will be necessary for the consuming plugin to revalidate the head instance against the `jenkins.scm.api.SCMSourceCriteria`.
Even if we could trust the content of the `jenkins.scm.api.SCMHeadEvent`, the revalidation would be a necessary step as we have no way of determining from a `jenkins.scm.api.SCMHeadEvent` whether the change has:

* Transitioned the criteria matching from `false` to `true`;
* Maintained the criteria matching in its current state; or
* Transitioned the criteria matching from `true` to `false`.

Thus *every* SCM API consuming plugin that listens for a `jenkins.scm.api.SCMEvent` will need to validate that event *against the criteria*.
This revalidation would be necessary even if we received a signed trusted event from the backing source control system.
This is why:

* The `jenkins.scm.api.SCMEvent` is always considered `Untrusted` - consuming plugins will be doing revalidation anyway, so it is simpler for consuming plugins to treat everything from an event as untrusted.
For example, if we receive a `jenkins.scm.api.SCMHeadEvent` saying that there is a new head with a specific revision.
The revalidation will involve checking if that revision contains the required marker content by calling `jenkins.scm.api.SCMSource.fetch()` with an observer that is only interested in the head mentioned in the event.
If a malicious event has provided a head that does not exist, then the observer will never be called.
The event provided a revision does not really matter as, the observer will be provided with the actual revision of the named head (though if the event provided revision matches the known revision of the head the consumer can even avoid the call to `jenkins.scm.api.SCMSource.fetch()` in the first place).

* The `jenkins.scm.api.SCMEvent` dispatch methods always push events to a background thread - *every* consuming plugin will need to perform revalidation of any claim made from an event.
The revalidation should not block the handling of the webhook that delivered the event, hence the SCM API provides a simpler contract for all consumers by ensuring that the events are always on a separate thread from the webhook processing thread.
====

Consumers of the SCM API may want more advanced criteria to check the contents of specific files in the head / branch.
Additionally, in some cases consumers of the SCM API may want to inspect specific files in the source control system in order to determine how to process that head / branch.
For example,

* when https://wiki.jenkins-ci.org/display/JENKINS/Pipeline+Multibranch+Plugin[Pipeline Multibranch Plugin] needs to build a specific revision of a specific branch, it first needs to parse the `Jenkinsfile` in order to determine the build plan.

* when https://wiki.jenkins-ci.org/display/JENKINS/Literate+Plugin[Literate Plugin] needs to build a specific revision of a specific branch, it first needs to parse the `README.md` in order to determine the matrix of execution environments against which to build.

Consumers of the SCM API cannot assume that every SCM API implementation has the ability for deep inspection of specific files at specific revisions and thus must fall back to performing a full check-out.

SCM API implementations indicate their support for deep inspection both by returning a non-`null` value from `jenkins.scm.api.SCMProbe.getRoot()` and/or by implementing the `jenkins.scm.api.SCMFileSystem.Builder` extension point.

The final areas of the SCM API of interest to implementers are categorization and branding.
Both of these areas can be considered completely optional.
As they provide for a significantly richer user experience for the end user, it is recommended to implement these areas of the SCM API.

The `jenkins.scm.api.SCMHead` instances can represent a number of different things:

* mainline development branches
* side feature branches
* tags or snapshots of branches at fixed revisions
* change requests to branches
* _etc._

Each source control system will have their own idiomatic terminology for each of these concepts.
For example:

* GitHub uses the term "Pull Request" to refer to a change request
* Gerrit uses the term "Change" to refer to a change request
* Perforce uses the term "Change Review" to refer to a change request
* Git and Subversion use the term "Tag" to refer to a tag
* Accurev uses the term "Snapshot" to refer to a tag

Each `jenkins.scm.api.SCMSourceDescriptor` should provide the concrete instances of the `jenkins.scm.api.SCMHeadCategory` that are potentially generated by their `jenkins.scm.api.SCMSource` instances.
Then each `jenkins.scm.api.SCMSource` instance can filter down that list to the actual categories that may be returned by that specific source.
For example, a GitHub source may return "Branches", "Pull Requests" and "Tags" but the user may have configured their specific source for a specific project to only build "Branches" and "Tags".

In an analgous way, the `jenkins.scm.api.SCMSource` instances themselves may have different terminology for each of the different source control systems:

* GitHub uses the term "Repository" to refer to primary repositories
* GitHub uses the term "Fork" to refer to forks of the primary repositories
* Accurev uses the term "Depot" to refer to repositories (using the term "repository" to refer to the collection of "depots")
* One way of mapping CVS concepts to the SCM API might use the term "Module" for `jenkins.scm.api.SCMSource` instances.

In general, it is anticipated that most `jenkins.scm.api.SCMNavigatorDescriptor` instances will only ever return a single `jenkins.scm.impl.UncategorizedSCMSourceCategory` instance using the concept name that users expect.
Thus,

* An `AccurevSCMNavigator.DescriptorImpl` would have
+
[source,java]
----
public class AccurevSCMNavigator extends SCMNavigator {
    // ...
    @Extension
    public static class DecriptorImpl extends SCMNavigatorDescriptor {
        // ...
        protected SCMSourceCategory[] createCategories() {
            return new SCMSourceCategory[]{
                new UncategorizedSCMSourceCategory(Messages._AccurevSCMNavigator_DepotSourceCategory())
            };
        }
    }
}
----
* A `CVSSCMNavigator.DescriptorImpl` would have
+
[source,java]
----
public class CVSSCMNavigator extends SCMNavigator {
    // ...
    @Extension
    public static class DecriptorImpl extends SCMNavigatorDescriptor {
        // ...
        protected SCMSourceCategory[] createCategories() {
            return new SCMSourceCategory[]{
                new UncategorizedSCMSourceCategory(Messages._CVSSCMNavigator_ModuleSourceCategory())
            };
        }
    }
}
----

The implementers of a GitHub SCM API would need to decide whether the forks should be listed as additional heads / branches of the primary repository or whether they should be listed as a separate category of sources.

When defining custom categorization, we also need to pay attention to the `getPronoun()` methods of:

* `jenkins.scm.api.SCMHead`
* `jenkins.scm.api.SCMSource` (which will fall through to `jenkins.scm.api.SCMSourceDescriptor`)
* `jenkins.scm.api.SCMNavigator` (which will fall through to `jenkins.scm.api.SCMNavigatorDescriptor`)

For example, with the Accurev source control system we might have:

[source,java]
----
public class AccurevSCMNavivator extends SCMNavigator {
    // ...
    @Extension
    public static class DecriptorImpl extends SCMNavigatorDescriptor {
        // ...
       public String getPronoun() {
           return "Repository"; // Better: Messages.AccurevSCMNavigator_RepositoryPronoun();
       }
       protected SCMSourceCategory[] createCategories() {
            return new SCMSourceCategory[]{
                new UncategorizedSCMSourceCategory(
                    new NonLocalizable("Depots")
                // Better: Messages._AccurevSCMNavigator_DepotSourceCategory()
                )
            };
        }
    }
}
public class AccurevSCMSource extends SCMSource {
    private boolean buildTags;
    // ...
    protected boolean isCategoryEnabled(@NonNull SCMHeadCategory category) {
        if (category instanceof TagSCMHeadCategory) {
            return buildTags;
        }
        return true;
    }

    @Extension
    public static class DecriptorImpl extends SCMNavigatorDescriptor {
        // ...
       public String getPronoun() {
           return "Depot"; // Better: Messages.AccurevSCMSource_RepositoryPronoun();
       }
       protected SCMHeadCategory[] createCategories() {
            return new SCMSourceCategory[]{
                new UncategorizedSCMSourceCategory(
                    new NonLocalizable("Streams")
                    // Better: Messages._AccurevSCMSource_StreamHeadCategory()
                ),
                new TagSCMHeadCategory(
                    new NonLocalizable("Snapshots")
                    // Better: Messages._AccurevSCMSource_SnapshotHeadCategory()
                )
            };
        }
    }
}
public class AccurevSCMHead extends SCMHead {
    // ...
    public String getPronoun() {
        return getAction(TagAction.class) == null ? "Stream" : "Snapshot"; //: Better with localization
    }
 }
----

The above represents the terminology and categorization that is appropriate for the Accurev source control system.

NOTE: When implementing categorization it is recommended to reuse an existing categorization class (with the terminology injected) rather than create a new categorization.
New categorizations should be added to the scm-api plugin by pull requests as this allows similar categories to be grouped.

Branding controls the visual icons that are used to represent the `jenkins.scm.api.SCMSource` and `jenkins.scm.api.SCMNavigator` instances.
Branding is determined by the `getIconClassName()` of the `jenkins.scm.api.SCMSourceDescriptor` and `jenkins.scm.api.SCMNavigatorDescriptor`.
Where these methods return non-null the corresponding icons will be used by consumers of the SCM API as the final fall-back icons.

=== Implementing `hudson.scm.SCM`

The `hudson.scm.SCM` API has been subject to significant evolution. Modern implementations should focus on implementing the following methods:

[source,java]
----
public class MySCM extends SCM {
    /*
     * all configuration fields should be private
     * mandatory fields should be final
     * non-mandatory fields should be non-final
     */

    @DataBoundConstructor
    public MySCM(/*mandatory configuration*/) {
        // ...
    }

    // for easier interop with SCMSource
    public MySCM(MySCMSource config) {
        // copy the configuratuion from the SCMSource
    }

    // Getters for all the configuration fields

    // use @DataBoundSetter to inject the non-mandatory configuration elements
    // as this will simplify the usage from pipeline

    @Override
    public boolean supportsPolling() {
        return true; // hopefully you do
    }

    @Override
    public boolean requiresWorkspaceForPolling() {
        return false; // hopefully you don't
    }

    // for easier interop with SCMSource
    public void setSCMHead(@NonNull SCMHead head, @CheckForNull SCMRevision revision) {
        // configure to checkout the specified head at the specific revision
        // if passed implementations that do not come from a MySCMSource then silently ignore
    }

    @Override
    public PollingResult compareRemoteRevisionWith(@Nonnull Job<?, ?> project, @Nullable Launcher launcher,
                                                   @Nullable FilePath workspace, @Nonnull TaskListener listener,
                                                   @Nonnull SCMRevisionState baseline)
            throws IOException, InterruptedException {
        if (baseline instanceof MySCMRevisionState) {
            //
            // get current revision in SCM
            // if your implementation of requiresWorkspaceForPolling() returns true then the
            // workspace and launcher parameters should be non-null and point to a
            // workspace and node to use for the comparison
            // NOTE: requiring a workspace for polling is a realy bad user experience
            // as obtaining a workspace may require the provisioning of build resources
            // from the Cloud API just to determine that there are no changes to build
            //
            if (baseline same as currentRevision) {
                return PollingResult.NO_CHANGES;
            } else {
                return PollingResult.SIGNIFICANT;
            }
        } else {
            return PollingResult.BUILD_NOW;
        }
    }

    @Override
    public void checkout(@Nonnull Run<?, ?> build, @Nonnull Launcher launcher, @Nonnull FilePath workspace,
                         @Nonnull TaskListener listener, @CheckForNull File changelogFile,
                         @CheckForNull SCMRevisionState baseline) throws IOException, InterruptedException {
        // do the checkout in the remote workspace using the supplied launcher
        // output from the checkout should be streamed to the listener

        // write the changelog to the changelog file (assuming it is non-null)
        // the changelog should be from the supplied baseline to the revision checked out

        // finally attach the revision state to the build's actions.
        build.addAction(new MySCMRevisionState(/*whatever you need*/));
    }

    @Override
    public ChangeLogParser createChangeLogParser() {
         return new MyChangeLogParser();
    }

    @Symbol("my")
    @Extension
    public static class DescriptorImpl extends SCMDescriptor<MySCM> {
       public DescriptorImpl() {
            super(MySCMRepositoryBrowser.class);
        }
        // ...
    }
}
----

[NOTE]
====
To simplify the implementation of the `jenkins.scm.api.SCMSource` we provide a constructor that takes the `MySCMSource` and a setter method to pin that source to a specific `SCMHead` and optionally a `SCMRevision`.

If the configuration for the `SCMHead` and/or the `SCMRevision` requires manipulation of final fields, then a constructor taking the `SCMSource`, `SCMHead` and `SCMRevision` would be equally appropriate.
====

You will also need to provide implementations of `SCMRevisionState` and `ChangeLogParser`.
You do not need to provide an implementation of `RepositoryBrowser` but you must at least provide an abstract base class with the appropriate methods for generating links from change log entries.

For simplification of integration with `jenkins.scm.api.SCMSource` and the new SCM API it is recommended to use a `SCMRevisionState` implementation that effectively defers to your implementation of `SCMRevision`

[source,java]
----
public class MySCMRevisionState extends SCMRevisionState implements Serializable {
    private static final long serialVersionUID = 1L;
    @NonNull
    private final MySCMRevision revision;

    public MySCMRevisionState(@NonNull MySCMRevision revision) {
        this.revision = revision;
    }

    public MySCMRevision getRevision() {
        return revision;
    }
}
----

The easiest format for the change log on disk is just to serialize the list of log entries using `XStream`.
If that on-disk format is used, then the change log parser can become relatively trivial:

[source,java]
----
public class MySCMChangeLogParser extends ChangeLogParser {
    @Override
    public ChangeLogSet<? extends ChangeLogSet.Entry> parse(Run build,
                                                            RepositoryBrowser<?> browser,
                                                            File changelogFile)
            throws IOException, SAXException {
        List<MySCMChangeLogEntry> entries =
                (List<MySCMChangeLogEntry>) Items.XSTREAM2.fromXML(changelogFile);
        return new MySCMChangeLogSet(build, browser, entries);
    }
}
public class MySCMChangeLogEntry extends ChangeLogSet.Entry {
    // ...
    /*package*/ void setParent(MySCMChangeLogSet parent) {
        super.setParent(parent);
    }
}
public class MySCMChangeLogSet extends ChangeLogSet<MySCMChangeLogEntry> {
    private final List<MySCMChangeLogEntry> entries;

    public MySCMChangeLogSet(Run<?, ?> build,
                             RepositoryBrowser<?> browser,
                             List<MySCMChangeLogEntry> entries) {
        super(build, browser);
        this.entries = new ArrayList<>(entries);
        // contract of ChangeLogSet.Entry is that parent must be set before
        // ChangeLogSet is exposed
        for (MySCMChangeLogEntry entry: this.entries) {
            entry.setParent(this);
        }
    }

    @Override
    public boolean isEmptySet() {
        return entries.isEmpty();
    }

    public Iterator<MySCMChangeLogEntry> iterator() {
        return entries.iterator();
    }
}
----

The `ChangeLogSet` implementation will also need Stapler views for `index` and `digest`.
When rendering the entries, the repository browser should be used to render links.
You should assume that any `RepositoryBrowser` you are provided is an implementation of the base class you specified in your `SCMDescriptor`.

=== Implementing `jenkins.scm.api.SCMSource`

The `jenkins.scm.api.SCMSource` API has been subject to some evolution.
The following are the recommended methods to implement:

[source,java]
----
public class MySCMSource extends SCMSource {
    /*
     * all configuration fields should be private
     * mandatory fields should be final
     * non-mandatory fields should be non-final
     */

    @DataBoundConstructor
    public MockSCMSource(/*mandatory configuration*/) {
        super(/* see note on ids*/);
    }

    public MockSCMSource(MySCMNavigator config, String name) {
        super(/* see note on ids*/);
    }

    // Getters for all the configuration fields

    // use @DataBoundSetter to inject the non-mandatory configuration elements
    // as this will simplify the usage from pipeline

    @Override
    protected void retrieve(@CheckForNull SCMSourceCriteria criteria,
                            @NonNull SCMHeadObserver observer,
                            @NonNull TaskListener listener)
        throws IOException, InterruptedException {
        Iterable<...> candidates = null;
        Set<SCMHead> includes = observer.getIncludes();
        if (includes != null) {
            // at least optimize for the case where the includes is one and only one
            if (includes.size() == 1 && includes.iterator().next() instanceof MySCMHead) {
                candidates = getSpecificCandidateFromSourceControl();
            }
        }
        if (candidates == null) {
            candidates = getAllCandiatesFromSourceControl();
        }
        for (candidate : candidates) {
            checkInterrupt(); // important to call this periodically
            SCMHead head = new ...;
            SCMRevision revision = new ...;
            if (criteria != null) {
                /* see note on SCMProbe */
                try (SCMProbe probe = createProbe(head, revision)) {
                    if (!criteria.isHead(probe, listener)) {
                        continue;
                    }
                }
                observer.observe(head, revision);
            }
        }
    }

    @NonNull
    @Override
    protected SCMProbe createProbe(@NonNull final SCMHead head, @CheckForNull final SCMRevision revision)
            throws IOException {
        /* see note on SCMProbe */

        // assuming we have a sutable implementation of SCMFileSystem
        return newProbe(head, revision);
    }

    @NonNull
    @Override
    public SCM build(@NonNull SCMHead head, @CheckForNull SCMRevision revision) {
        MySCM result = new MySCM(this);
        result.setHead(head, revision);
        return result;
    }


    @NonNull
    @Override
    protected Map<Class<? extends Action>, Action> retrieveActions(@NonNull TaskListener listener)
            throws IOException, InterruptedException {
        Map<Class<? extends Action>, Action> result = new HashMap<>();
        // if your SCM provides support for metadata at the "SCMSource" level
        // then you probably want to return at least a `jenkins.branch.MetadataAction`
        // from this method. The listener can be used to log the interactions
        // with the backing source control system.
        return result;
    }

    @NonNull
    @Override
    protected Map<Class<? extends Action>, Action> retrieveActions(@NonNull SCMHead head,
                                                                   @NonNull TaskListener listener)
            throws IOException, InterruptedException {
        Map<Class<? extends Action>, Action> result = new HashMap<>();
        // if your SCM provides support for metadata at the "SCMHead" level
        // then you probably want to return the correct metadata actions
        // from this method. The listener can be used to log the interactions
        // with the backing source control system.
        return result;
    }

    @NonNull
    @Override
    protected Map<Class<? extends Action>, Action> retrieveActions(@NonNull SCMRevision revision,
                                                                   @NonNull TaskListener listener)
            throws IOException, InterruptedException {
        Map<Class<? extends Action>, Action> result = new HashMap<>();
        // if your SCM provides support for metadata at the "SCMRevision" level
        // then you probably want to return the correct metadata actions
        // from this method. The listener can be used to log the interactions
        // with the backing source control system.
        return result;
    }

    // This method is only required if you have more than one category and
    // it is user configurable whether any specific source may opt in/out of
    // specific categories
    @Override
    protected boolean isCategoryEnabled(@NonNull SCMHeadCategory category) {
        if (category instanceof ChangeRequestSCMHeadCategory) {
            return includeChangeRequests;
        }
        if (category instanceof TagSCMHeadCategory) {
            return includeTags;
        }
        return true;
    }

    @Symbol("my")
    @Extension
    public static class DescriptorImpl extends SCMSourceDescriptor {
        @Nonnull
        @Override
        public String getDisplayName() {
            return "My SCM";
        }

        // This method is only required if you need more than one category
        // or if the categories need to use idiomatic names specific to
        // your source control system.
        @NonNull
        @Override
        protected SCMHeadCategory[] createCategories() {
            return new SCMHeadCategory[]{
                    new UncategorizedSCMHeadCategory(),
                    new ChangeRequestSCMHeadCategory(),
                    new TagSCMHeadCategory()
            };
        }
    }
}
----

[NOTE]
.SCMSource IDs
====
The SCMSource's IDs are used to help track the SCMSource that a SCMHead instance originated from.

If - *and only if* - you are certain that you can construct a definitive ID from the configuration details of your SCMSource then implementations are encouraged to use a computed ID.

In all other cases, implementations should use the default generated ID mechanism.

An example of how a generated ID could be definitively constructed would be:

* Start with the definitive URL of the server including the port
* Append the name of the source
* Append a SHA-1 hash of the other configuration options (this is because users can add the same source with different configuration options)

If users add the same source with the same configuration options twice to the same owner, with the above ID generation scheme, it should not matter as both sources would be idempotent.

By starting with the server URL and then appending the name of the source we might be able to more quickly route events.

*The observant reader* will spot the issue above, namely that we need to start from an URL that is definitive.
Most SCM systems can be accessed via multiple URLs.
For example, GitHub can be accessed at both `https://github.com/` and `https://github.com./`.
For internal source control systems, this can get even more complex as some users may configure using the IP address, some may configure using a hostname without a domain, some may configure using a fully qualified hostname... also ID generation should not require a network connection or any external I/O.
====

[NOTE]
.SCMProbe: implement custom or leverage SCMFileSystem
====
The above example uses the default implementation of `SCMSource.newProbe(_head_, _revision_)` to instantiate the `SCMProbe`.
This will only work if you have provided an implementation of `SCMFileSystem.Builder`.

If your source control system cannot support an implementation of `SCMFileSystem`, i.e. it cannot support deep inspection, then you will need to provide your own implementation of SCMProbe.

If your source control system cannot support even the `SCMProbe.stat(_path_)` style of inspection then you will have to ignore the criteria and allow all heads to be observed.
====
